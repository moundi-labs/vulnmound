// CVE-2025-9566
// https://github.com/containers/podman/commit/43fbde4e665fe6cee6921868f04b7ccd3de5ad89

package main

import (
	"fmt"
	"os"
	"strings"

	securejoin "github.com/cyphar/filepath-securejoin"
	"golang.org/x/sys/unix"
)

// Secure function that prevents symlink attacks
// This simulates the fix implemented in Podman
func secureCreateFile(mountPoint, fileName string, data []byte) error {
	// * SECURE: Validate that fileName doesn't contain path separators
	f, err := openPathSafely(mountPoint, fileName)
	if err != nil {
		return err
	}

	// Set file permissions
	if err := f.Chmod(os.FileMode(0644)); err != nil {
		return err
	}

	fmt.Printf("Successfully created secure file: %s\n", f.Name())
	return nil
}

// Secure volume data processing
func processVolumeDataSecure(mountPoint string, items map[string][]byte) error {
	fmt.Printf("Processing volume data securely at mountpoint: %s\n", mountPoint)

	for fileName, data := range items {
		fmt.Printf("Processing item: %s (size: %d bytes)\n", fileName, len(data))

		// This is the secure version
		if err := secureCreateFile(mountPoint, fileName, data); err != nil {
			return err
		}
	}

	return nil
}

// openSymlinkPath opens the path under root using securejoin.OpenatInRoot().
func openSymlinkPath(root *os.File, unsafePath string, flags int) (*os.File, error) {
	file, err := securejoin.OpenatInRoot(root, unsafePath)
	if err != nil {
		return nil, err
	}
	return securejoin.Reopen(file, flags)
}

// openPathSafely opens the given name under the trusted root path, the unsafeName
// must be a single path component and not contain "/".
// The resulting path will be opened or created if it does not exists.
// Following of symlink is done within staying under root, escapes outsides
// of root are not allowed and prevent.
//
// This custom function is needed because securejoin.SecureJoin() is not race safe
// and the volume might be mounted in another container that could swap in a symlink
// after the function ahs run. securejoin.OpenInRoot() doesn't work either because
// it cannot create files and doesn't work on freebsd.
func openPathSafely(root, unsafeName string) (*os.File, error) {
	// If the unsafeName(/) contains path separator, return an error
	if strings.Contains(unsafeName, "/") {
		return nil, fmt.Errorf("name %q must not contain path separator", unsafeName)
	}
	fdDir, err := os.OpenFile(root, unix.O_RDONLY, 0)
	if err != nil {
		return nil, err
	}
	defer fdDir.Close()
	flags := unix.O_CREAT | unix.O_WRONLY | unix.O_TRUNC | unix.O_CLOEXEC
	// Openat with O_NOFOLLOW to prevent symlink following
	fd, err := unix.Openat(int(fdDir.Fd()), unsafeName, flags|unix.O_NOFOLLOW, 0o644)
	if err == nil {
		return os.NewFile(uintptr(fd), unsafeName), nil
	}
	if err == unix.ELOOP {
		return openSymlinkPath(fdDir, unsafeName, flags)
	}
	return nil, &os.PathError{Op: "openat", Path: unsafeName, Err: err}
}
